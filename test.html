<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Battle Cats Pack å¾©å·ãƒ„ãƒ¼ãƒ«</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js"></script>
</head>
<body>
  <h2>Battle Cats Pack å¾©å·ãƒ„ãƒ¼ãƒ«ï¼‘</h2>
  <label>listãƒ•ã‚¡ã‚¤ãƒ«: <input type="file" id="listFile" /></label><br />
  <label>packãƒ•ã‚¡ã‚¤ãƒ«: <input type="file" id="packFile" /></label><br />
  <label><input type="checkbox" id="isJP" /> æ—¥æœ¬ç‰ˆ (v10.8+)</label><br />
  <button onclick="decrypt()">å¾©å·åŒ–</button>
  <br /><br />
  <progress id="progressBar" value="0" max="100" style="width: 300px;"></progress>
  <div id="status"></div>
  <pre id="log" style="background:#f0f0f0; padding:10px; max-height:300px; overflow:auto;"></pre>

  <script>
    function log(msg) {
      const logBox = document.getElementById("log");
      logBox.textContent += msg + "\n";
    }

    function wordArrayToUint8Array(wordArray) {
      const { words, sigBytes } = wordArray;
      const u8 = new Uint8Array(sigBytes);
      for (let i = 0; i < sigBytes; i++) {
        u8[i] = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
      }
      return u8;
    }

    function decryptListFile(buffer) {
      try {
        const key = CryptoJS.MD5("pack");
        const wordArray = CryptoJS.lib.WordArray.create(new Uint8Array(buffer));
        const decrypted = CryptoJS.AES.decrypt(
          { ciphertext: wordArray },
          key,
          { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.Pkcs7 }
        );
        const u8 = wordArrayToUint8Array(decrypted);

        // ãƒã‚¤ãƒŠãƒªã‚’æ”¹è¡Œã§åˆ†å‰²ã—ã€å„è¡Œã‚’UTF-8ã§ãƒ‡ã‚³ãƒ¼ãƒ‰
        const lines = [];
        let current = [];
        for (let i = 0; i < u8.length; i++) {
          const byte = u8[i];
          if (byte === 0x0a || byte === 0x0d) {
            if (current.length > 0) {
              const line = new TextDecoder("utf-8", { fatal: false }).decode(new Uint8Array(current));
              if (line.includes(",")) lines.push(line);
              current = [];
            }
            if (byte === 0x0d && u8[i + 1] === 0x0a) i++;
          } else {
            current.push(byte);
          }
        }
        if (current.length > 0) {
          const line = new TextDecoder("utf-8", { fatal: false }).decode(new Uint8Array(current));
          if (line.includes(",")) lines.push(line);
        }

        log("âœ… listãƒ•ã‚¡ã‚¤ãƒ«ã®å¾©å·ã¨CSVåˆ†è§£ã«æˆåŠŸ");
        return lines;
      } catch (e) {
        log("âŒ listãƒ•ã‚¡ã‚¤ãƒ«ã®å¾©å·ã«å¤±æ•—: " + e);
        throw e;
      }
    }

    async function decrypt() {
      const listInput = document.getElementById("listFile").files[0];
      const packInput = document.getElementById("packFile").files[0];
      const isJP = document.getElementById("isJP").checked;
      const progressBar = document.getElementById("progressBar");
      const status = document.getElementById("status");
      const logBox = document.getElementById("log");
      logBox.textContent = "";
      status.textContent = "";
      progressBar.value = 0;

      if (!listInput || !packInput) {
        alert("ä¸¡æ–¹ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼");
        return;
      }

      const listBuffer = await listInput.arrayBuffer();
      const packBuffer = await packInput.arrayBuffer();

      let lines;
      try {
        lines = decryptListFile(listBuffer);
      } catch {
        status.textContent = "listãƒ•ã‚¡ã‚¤ãƒ«ã®å¾©å·ã«å¤±æ•—ã—ã¾ã—ãŸã€‚";
        return;
      }

      log(`ğŸ“„ listå†…ã®ãƒ•ã‚¡ã‚¤ãƒ«æ•°: ${lines.length}`);
      const packBytes = new Uint8Array(packBuffer);
      const zip = new JSZip();

      for (let i = 0; i < lines.length; i++) {
        const [name, offsetStr, lengthStr] = lines[i].split(",");
        const offset = parseInt(offsetStr);
        const length = parseInt(lengthStr);
        let chunk = packBytes.slice(offset, offset + length);

        try {
          const pkName = packInput.name.toLowerCase();
          let key, iv, mode;

          if (pkName.includes("server")) {
            key = CryptoJS.MD5("battlecats");
            mode = CryptoJS.mode.ECB;
            iv = null;
          } else {
            key = CryptoJS.enc.Hex.parse(isJP
              ? "d754868de89d717fa9e7b06da45ae9e3"
              : "0ad39e4aeaf55aa717feb1825edef521");
            iv = CryptoJS.enc.Hex.parse(isJP
              ? "40b2131a9f388ad4e5002a98118f6128"
              : "d1d7e708091941d90cdf8aa5f30bb0c2");
            mode = CryptoJS.mode.CBC;
          }

          if (!pkName.includes("imagedatalocal")) {
            const wordArray = CryptoJS.lib.WordArray.create(chunk);
            const decrypted = CryptoJS.AES.decrypt(
              { ciphertext: wordArray },
              key,
              { mode, iv, padding: CryptoJS.pad.Pkcs7 }
            );
            chunk = wordArrayToUint8Array(decrypted);
          }

          zip.file(name, chunk);
          log(`âœ… å¾©å·æˆåŠŸ: ${name}`);
        } catch (e) {
          log(`âš ï¸ å¾©å·å¤±æ•—: ${name} - ${e}`);
          continue;
        }

        progressBar.value = ((i + 1) / lines.length) * 100;
        status.textContent = `å¾©å·ä¸­: ${i + 1} / ${lines.length}`;
        await new Promise(r => setTimeout(r, 10));
      }

      const blob = await zip.generateAsync({ type: "blob" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "decrypted_files.zip";
      a.textContent = "â¬‡ï¸ å¾©å·å®Œäº†ï¼ã“ã“ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰";
      status.innerHTML = "";
      status.appendChild(a);
      log("ğŸ‰ å…¨ãƒ•ã‚¡ã‚¤ãƒ«ã®å¾©å·ãŒå®Œäº†ã—ã¾ã—ãŸï¼");
    }
  </script>
</body>
</html>

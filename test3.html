<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Item TSV Parser</title>
  <style>
    body { font-family: sans-serif; padding: 1em; }
    pre { background: #f0f0f0; padding: 1em; white-space: pre-wrap; max-height: 400px; overflow: auto; }
  </style>
</head>
<body>
  <h1>item.tsv → JSON 変換</h1>
  <input type="file" id="fileInput" accept=".tsv,.txt"><br><br>
  <button id="parseBtn">解析してJSON出力</button>
  <pre id="output">ここに結果が表示されます</pre>

  <script>
    let rawText = '';

    document.getElementById('fileInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
        rawText = event.target.result;
      };
      reader.readAsText(file, 'utf-8');
    });

    document.getElementById('parseBtn').addEventListener('click', () => {
      if (!rawText) return;
      const lines = rawText.trim().split('\n').filter(line => line.trim() && line !== '[start]' && line !== '[end]');
      const results = lines.map(parseItemLine);
      document.getElementById('output').textContent = JSON.stringify(results, null, 2);
    });

    function decodeWeekdays(bitmask) {
      if (bitmask === 0) return [];
      const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
      return days.filter((_, i) => (bitmask >> i) & 1);
    }

    function estimateTimeBlockLength(parts, startIndex, blockCount) {
      let idx = startIndex + 1;
      try {
        for (let i = 0; i < blockCount; i++) {
          const yearCount = parseInt(parts[idx++], 10);
          if (isNaN(yearCount)) return -1;
          idx += yearCount * 4;

          const monthCount = parseInt(parts[idx++], 10);
          if (isNaN(monthCount)) return -1;
          idx += monthCount;

          const weekdayBits = parseInt(parts[idx++], 10);
          if (isNaN(weekdayBits)) return -1;

          const timeCount = parseInt(parts[idx++], 10);
          if (isNaN(timeCount)) return -1;
          idx += timeCount * 2;
        }
        return idx - startIndex;
      } catch {
        return -1;
      }
    }

    function parseItemLine(line) {
      const parts = line.trim().split('\t').filter(x => x !== '');
      const header = {
        startDate: parts[0],
        startTime: parts[1],
        endDate: parts[2],
        endTime: parts[3],
        minVersion: parts[4],
        maxVersion: parts[5]
      };

      let index = 6;
      index += 2; // skip 2 unused fields

      const timeBlocks = [];
      const timeBlockCount = parseInt(parts[index], 10);

      if (!isNaN(timeBlockCount) && timeBlockCount > 0) {
        const estimatedLength = estimateTimeBlockLength(parts, index, timeBlockCount);
        const remaining = parts.length - (index + estimatedLength);
        if (estimatedLength > 0 && remaining >= 7) {
          index++;
          for (let i = 0; i < timeBlockCount; i++) {
            const block = {
              dateRanges: [],
              monthDays: [],
              weekdays: [],
              timeRanges: []
            };

            const yearCount = parseInt(parts[index++], 10);
            for (let j = 0; j < yearCount; j++) {
              const startDay = parts[index++];
              const startTime = parts[index++];
              const endDay = parts[index++];
              const endTime = parts[index++];
              block.dateRanges.push({ start: `${startDay} ${startTime}`, end: `${endDay} ${endTime}` });
            }

            const monthCount = parseInt(parts[index++], 10);
            for (let j = 0; j < monthCount; j++) {
              block.monthDays.push(parseInt(parts[index++], 10));
            }

            const weekdayBits = parseInt(parts[index++], 10);
            block.weekdays = decodeWeekdays(weekdayBits);

            const timeRangeCount = parseInt(parts[index++], 10);
            for (let j = 0; j < timeRangeCount; j++) {
              const start = parts[index++];
              const end = parts[index++];
              block.timeRanges.push([start, end]);
            }

            timeBlocks.push(block);
          }
        } else {
          index++; // skip invalid block count
        }
      } else {
        index++; // skip 0 or invalid
      }

      const eventId = parseInt(parts[index++] || "0", 10);
      const giftType = parseInt(parts[index++] || "0", 10);
      const giftAmount = parseInt(parts[index++] || "0", 10);
      const title = parts[index++] || "";
      const messageOrUrl = parts[index++] || "";
      const isUrl = messageOrUrl.startsWith('http');
      index += 2; // skip unknown fields
      const repeatFlag = parseInt(parts[index++] || "0", 10);

      return {
        header,
        timeBlocks,
        gift: {
          eventId,
          giftType,
          giftAmount,
          title,
          message: isUrl ? "" : messageOrUrl,
          url: isUrl ? messageOrUrl : "",
          repeatFlag
        }
      };
    }
  </script>
</body>
</html>

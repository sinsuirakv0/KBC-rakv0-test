<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>KBC SAVE_DATA-storage</title>

  <link rel="stylesheet" href="../assets/style.css">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
<link rel="icon" href="../assets/favicon.ico">
<meta property="og:title" content="KBC SAVE_DATA-storage">
<meta property="og:description" content="SAVE_DATAの保存とかに【仮】">
<meta property="og:image" content="../assets/preview.png">
<meta property="og:url" content="https://kbc-rakv0.vercel.app/">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="KBC SAVE_DATA-storage">
<meta name="twitter:description" content="SAVE_DATAの保存とかに【仮】">
<meta name="twitter:image" content="../assets/preview.png">
</head>
<body class="fade-in">
  <div class="container">
    <header class="header">
      <div class="header-left">
        <img src="../assets/logo.png" alt="ロゴ" id="logo" style="cursor: pointer;"> 
        <h1 class="site-title">KBC</h1>
      </div>
      <nav class="nav">
        <a href="../index.html">Home</a>
        <a href="index.html">secret home</a>
      </nav>
    </header>

    <main class="grid">
      <!-- 左カラム: 保存フォーム -->
      <section class="card">
        <div class="card-header">
          <h3>ファイルを保存</h3>
          <span class="tag">IndexedDB</span>
        </div>

        <div class="small" id="status">準備完了</div>

        <div class="controls" style="margin-top:12px;">
          <input type="file" id="fileInput" />
          <input type="text" id="nameInput" placeholder="表示名（省略可）" />
          <input type="text" id="memoInput" placeholder="メモ（省略可）" />
          <div style="display:flex; gap:8px;">
            <button id="saveBtn">保存</button>
            <button id="clearBtn" class="secondary">DB初期化</button>
          </div>
        </div>

        <p class="small" style="margin-top:12px;">
          保存はブラウザのローカルストレージ（IndexedDB）に行われます。プライベートモードや一部ブラウザでは制限があります。
        </p>
      </section>

      <!-- 右カラム: 一覧 -->
      <section class="card">
        <div class="card-header">
          <h3>保存済みファイル</h3>
          <span class="tag">一覧</span>
        </div>

        <div id="fileList" class="list">
          <!-- 動的に挿入 -->
        </div>
      </section>
    </main>

    <footer>
      <div class="small">© あなたのサイト</div>
    </footer>
  </div>

<script>
/* IndexedDB 基盤コード */
const DB_NAME = 'my-files-db';
const DB_VERSION = 1;
const STORE_NAME = 'files';

function openDb() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        const store = db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
        store.createIndex('timestamp', 'timestamp', { unique: false });
      }
    };
    req.onsuccess = (e) => resolve(e.target.result);
    req.onerror = (e) => reject(e.target.error);
  });
}

async function getStorageEstimate() {
  if (navigator.storage && navigator.storage.estimate) {
    try {
      return await navigator.storage.estimate();
    } catch (err) {
      return null;
    }
  }
  return null;
}

async function saveFile({ name, blob, memo = '' }) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    const timestamp = Math.floor(Date.now() / 1000); // UNIX秒
    const record = { name, blob, memo, timestamp };
    const req = store.add(record);
    req.onsuccess = (e) => resolve({ id: e.target.result, ...record });
    req.onerror = (e) => reject(e.target.error);
  });
}

async function getAllFiles() {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    const index = store.index('timestamp');
    const items = [];
    const req = index.openCursor(null, 'prev'); // 降順
    req.onsuccess = (e) => {
      const cursor = e.target.result;
      if (cursor) {
        items.push(cursor.value);
        cursor.continue();
      } else {
        resolve(items);
      }
    };
    req.onerror = (e) => reject(e.target.error);
  });
}

async function getFileById(id) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    const req = store.get(id);
    req.onsuccess = (e) => resolve(e.target.result);
    req.onerror = (e) => reject(e.target.error);
  });
}

async function updateMemo(id, newMemo) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    const getReq = store.get(id);
    getReq.onsuccess = (e) => {
      const rec = e.target.result;
      if (!rec) return reject(new Error('Record not found'));
      rec.memo = newMemo;
      const putReq = store.put(rec);
      putReq.onsuccess = () => resolve(rec);
      putReq.onerror = (ev) => reject(ev.target.error);
    };
    getReq.onerror = (ev) => reject(ev.target.error);
  });
}

async function deleteFile(id) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    const req = store.delete(id);
    req.onsuccess = () => resolve();
    req.onerror = (e) => reject(e.target.error);
  });
}

async function clearDatabase() {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    const req = store.clear();
    req.onsuccess = () => resolve();
    req.onerror = (e) => reject(e.target.error);
  });
}

function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename || 'file';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

async function saveFileWithQuotaCheck({ name, blob, memo }) {
  const est = await getStorageEstimate();
  if (est && typeof est.quota === 'number') {
    const usage = est.usage || 0;
    const quota = est.quota;
    const blobSize = blob.size || 0;
    if (usage + blobSize > quota * 0.9) {
      throw new Error('ストレージ容量が不足する可能性があります。保存を中止しました。');
    }
  }
  return saveFile({ name, blob, memo });
}

/* UI ロジック */
const fileInput = document.getElementById('fileInput');
const nameInput = document.getElementById('nameInput');
const memoInput = document.getElementById('memoInput');
const saveBtn = document.getElementById('saveBtn');
const fileList = document.getElementById('fileList');
const status = document.getElementById('status');
const clearBtn = document.getElementById('clearBtn');

function setStatus(text, isError = false) {
  status.textContent = text;
  status.style.color = isError ? '#f87171' : 'var(--muted)';
}

function formatTimestamp(ts) {
  try {
    const d = new Date(ts * 1000);
    return d.toLocaleString();
  } catch {
    return String(ts);
  }
}

async function refreshList() {
  fileList.innerHTML = '';
  try {
    const items = await getAllFiles();
    if (!items.length) {
      fileList.innerHTML = '<div class="small">保存されたファイルはありません。</div>';
      return;
    }
    for (const rec of items) {
      const el = document.createElement('div');
      el.className = 'item';

      const meta = document.createElement('div');
      meta.className = 'meta';

      const nameEl = document.createElement('div');
      nameEl.className = 'name';
      nameEl.textContent = rec.name || '(無名ファイル)';

      const timeEl = document.createElement('div');
      timeEl.className = 'time';
      timeEl.textContent = `保存日時: ${formatTimestamp(rec.timestamp)} （UNIX: ${rec.timestamp}）`;

      const memoEl = document.createElement('div');
      memoEl.className = 'memo';
      const memoTextarea = document.createElement('textarea');
      memoTextarea.value = rec.memo || '';
      memoTextarea.placeholder = 'メモを入力';
      memoTextarea.addEventListener('change', async () => {
        try {
          await updateMemo(rec.id, memoTextarea.value);
          setStatus('メモを更新しました。');
        } catch (err) {
          setStatus('メモ更新に失敗しました: ' + err.message, true);
        }
      });
      memoEl.appendChild(memoTextarea);

      meta.appendChild(nameEl);
      meta.appendChild(timeEl);
      meta.appendChild(memoEl);

      const actions = document.createElement('div');
      actions.className = 'actions';

      const dlBtn = document.createElement('button');
      dlBtn.textContent = 'ダウンロード';
      dlBtn.style.background = 'transparent';
      dlBtn.style.color = 'var(--accent)';
      dlBtn.style.border = '1px solid rgba(255,255,255,0.04)';
      dlBtn.style.padding = '8px 10px';
      dlBtn.style.borderRadius = '8px';
      dlBtn.addEventListener('click', async () => {
        try {
          const r = await getFileById(rec.id);
          if (r && r.blob) {
            downloadBlob(r.blob, r.name || 'file');
            setStatus('ダウンロードを開始しました。');
          } else {
            setStatus('ファイルが見つかりません。', true);
          }
        } catch (err) {
          setStatus('ダウンロード失敗: ' + err.message, true);
        }
      });

      const delBtn = document.createElement('button');
      delBtn.textContent = '削除';
      delBtn.className = 'secondary';
      delBtn.style.padding = '8px 10px';
      delBtn.style.borderRadius = '8px';
      delBtn.addEventListener('click', async () => {
        if (!confirm('本当に削除しますか？')) return;
        try {
          await deleteFile(rec.id);
          setStatus('削除しました。');
          refreshList();
        } catch (err) {
          setStatus('削除に失敗しました: ' + err.message, true);
        }
      });

      actions.appendChild(dlBtn);
      actions.appendChild(delBtn);

      el.appendChild(meta);
      el.appendChild(actions);
      fileList.appendChild(el);
    }
  } catch (err) {
    fileList.innerHTML = '<div class="small" style="color:#f87171">一覧取得に失敗しました: ' + err.message + '</div>';
  }
}

saveBtn.addEventListener('click', async () => {
  const file = fileInput.files && fileInput.files[0];
  if (!file) {
    setStatus('ファイルを選択してください。', true);
    return;
  }
  const name = nameInput.value.trim() || file.name;
  const memo = memoInput.value.trim();
  setStatus('保存中...');
  try {
    await saveFileWithQuotaCheck({ name, blob: file, memo });
    setStatus('保存しました。');
    fileInput.value = '';
    nameInput.value = '';
    memoInput.value = '';
    refreshList();
  } catch (err) {
    setStatus('保存に失敗しました: ' + err.message, true);
  }
});

clearBtn.addEventListener('click', async () => {
  if (!confirm('データベースを初期化します。保存済みのファイルはすべて削除されます。続けますか？')) return;
  try {
    await clearDatabase();
    setStatus('データベースを初期化しました。');
    refreshList();
  } catch (err) {
    setStatus('初期化に失敗しました: ' + err.message, true);
  }
});

/* 初期化 */
(async function init() {
  try {
    const est = await getStorageEstimate();
    if (est && typeof est.quota === 'number') {
      const qMB = Math.round(est.quota / (1024*1024));
      const uMB = Math.round((est.usage || 0) / (1024*1024));
      setStatus(`ストレージ見積: 使用 ${uMB}MB / クォータ ${qMB}MB`);
    } else {
      setStatus('ストレージ見積が利用できません（ブラウザ依存）。');
    }
  } catch {
    setStatus('準備完了');
  }
  refreshList();
})();
</script>
</body>
</html>
